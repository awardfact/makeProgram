실행 방식

이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수 관리, 호출된 콜백 함수 실행 순서 결정
백그라운드 : setTimeout같은 타이머나 이벤트 리스너가 대기하는 곳
태스트 큐 : 이벤트 발생 후 백그라운드에서 태스트 큐로 타이머나 이벤트 리스터 콜백 함수 보냄

setTimeout이 실행되면 타이머와 함께 백그라운드로 보내지고 시간이 지나면 태스크 큐로 보내진다
이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 하나씩 가져와 호출 스택에 넣는다
(setTimeout 시간이 지나도 태스크 큐에 작업이 있을 수가 있어서 setTimeout의 시간이 정확하지 않을 수있다)

블로킹 : 이전 작업이 끝나야만 다음 작업 실행(자바스크립트)
논블로킹 : 이전작업이 끝날때까지 대기하지 않고 다음 작업 수행(I/O)

블로킹만 있으면 작업 시간이 느려질 수 있어서 논 블로킹 방식으로 코딩하는 습관을 들여야 함
ex) setTimeout(function(){} , 0)  (0밀리초지만 브라우저는 5ms, 노드는 1ms의 지연이 있다)
오래걸리는 작업을 논블로킹으로 바꿔서 간단한 작업먼저 끝날 수 있게 하는것이 좋음


프로세스와 스레드

프로세스 : 운영체제에서 할당하는 작업 단위 프로세스 간에는 자원공유 X
스레드 : 프로세스 내에서 실행되는 흐름 단위 프로세스에서 스레드를 여러 개 생성해 동시에 작업을 처리
할수있음 스레드는 부모 프로세스의 자원을 공유 

노드는 싱글 스레드는 아니지만 제어할 수 있는 스레드는 하나이다

스래드풀과 워커 스래드의 경우는 멀티 스래드를 사용한다

스레드풀 : 노드가 특정 동작할떄 스스로 멀티 스레드 사용ex)암호화 입출력 압축
워커스레드 : 노드에서 멀티 스레드를 사용할 수 있게 해준다 

노드 특징
노드는 웹 서버가 내장되어있다 , 개발 언어로 자바스크립트를 사용한다 , 싱글스레드를 사용
CPU연산을 많이 요구하는 작업에는 약하지만 개수는 많지만 작은 데이터를 주고받을떄 유리
JSON과 호환이 잘됨 , 서버 규모가 커졌을 떄 서버 관리가 어렵다 , 스레드가 하나라 그 스레드가
멈추지 않도록 관리해줘야 한다 


노드에서 this
최상위 스코프에 존재하는 this는 module, exports를 가리키지만 함수 안에서의 this는 global객체를 가리킨다

require모듈이나 export모듈은 상단 하단에 위치하지 않아도된다


노드에서 os모듈을 사용하면 운영체제의 정보를 가져올 수 있다.
ex) const os = require('os');  os.type();

__filename : 현재 파일의 이름을 나타낸다
__dirname :현재 폴더의 경로를 나타낸다 
path.extname(string) - 파일의 확장자를 나타낸다 
path.relative(string) - 경로를 두 개 넣으면 첫 번쨰 에서 두 번째 경로로 가는방법을 알려준다 

url모듈은 url에 관한 여러 기능을 제공한다

searchParams : 키와 값을을 모두 가져옴

ex) const {URL} = require('url');
const myURL = new URL('https://github.com/awardfact/makeProgram/tree/master/node?page=3&limit=10&category=nodejs&category=javascript');
console.log('searchParams : ' , myURL.searchParams);
console.log('searchParams.getAll() : ', myURL.searchParams.getAll('category'));
console.log('searchParams.get() :  ' , myURL.searchParams.get('limit'));
console.log('searchParams.has() : ', myURL.searchParams.has('page'));


querystring - WHATWG 방식의 url 대신 기존 노드의 url을 사용할떄 search부분을 사용하기 쉽게 객체로 만드는 모듈

querystring.parse(쿼리) : url의 query부분을 자바스크립트 객채로 분해
querystring.stringify(객체) : 분해된 query객체를 다시 조립한다 

crypto모듈 - 암호화를 도와주는 모듈이다 

해쉬만드는 코드 
ex)const crypto = require('crypto');
console.log('base64 :' , crypto.createHash('sha512').update('password').digest('base64') );
 
createHash(알고리즘) - 해쉬에 사용할 알고리즘을 넣는다
update(문자열) -  변환할 문자열을 넣는다
digest(인코딩) - 인코딩할 알고리즘을 넣는다 base64, hex, latin1이 주로 사용되는데 base가 가장 짧아 많이 이용된다 

현재 주로 비밀번호 알고리즘으로 pbkdf2 , bcrypt, scrypt 사용한다 pbkdf2는 노드에서 지원한다  
사용예시) crypto.pbkdf2('비밀번호' , salt , 10000 , 64, 'sha512' , (err,key) =>{
        console.log('password' ,  key.toString('base64'));
    });

pbkdf2 의 매개변수로 비밀번호, salt, 반복횟수 , 출력 바이트, 해시 알고리즘을 넣는다 

양방향 암호화는 cipher를 이용한다 
사용예시)const algorithm = 'aes-256-cbc';
const key = 'abcdefghijklmnopqrstuvwxyz123456';
const iv = '1234567890123456';
const cipher = crypto.createCipheriv(algorithm,key,iv);
let result = cipher.update('암호화할 문장' , 'utf-8' , 'base64');
result += cipher.final('base64');
console.log('암호화 : ' , result);  
const decipher = crypto.createDecipheriv(algorithm,key,iv);
let result2 = decipher.update(result, 'base64' , 'utf-8');
result2 += decipher.final('utf-8');
console.log('복호화 :' , result2);

util 모듈은 각종 편의 기능들을 모아놓은 모듈이다

