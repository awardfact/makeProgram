실행 방식

이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수 관리, 호출된 콜백 함수 실행 순서 결정
백그라운드 : setTimeout같은 타이머나 이벤트 리스너가 대기하는 곳
태스트 큐 : 이벤트 발생 후 백그라운드에서 태스트 큐로 타이머나 이벤트 리스터 콜백 함수 보냄

setTimeout이 실행되면 타이머와 함께 백그라운드로 보내지고 시간이 지나면 태스크 큐로 보내진다
이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 하나씩 가져와 호출 스택에 넣는다
(setTimeout 시간이 지나도 태스크 큐에 작업이 있을 수가 있어서 setTimeout의 시간이 정확하지 않을 수있다)

블로킹 : 이전 작업이 끝나야만 다음 작업 실행(자바스크립트)
논블로킹 : 이전작업이 끝날때까지 대기하지 않고 다음 작업 수행(I/O)

블로킹만 있으면 작업 시간이 느려질 수 있어서 논 블로킹 방식으로 코딩하는 습관을 들여야 함
ex) setTimeout(function(){} , 0)  (0밀리초지만 브라우저는 5ms, 노드는 1ms의 지연이 있다)
오래걸리는 작업을 논블로킹으로 바꿔서 간단한 작업먼저 끝날 수 있게 하는것이 좋음


프로세스와 스레드

프로세스 : 운영체제에서 할당하는 작업 단위 프로세스 간에는 자원공유 X
스레드 : 프로세스 내에서 실행되는 흐름 단위 프로세스에서 스레드를 여러 개 생성해 동시에 작업을 처리
할수있음 스레드는 부모 프로세스의 자원을 공유 

노드는 싱글 스레드는 아니지만 제어할 수 있는 스레드는 하나이다

스래드풀과 워커 스래드의 경우는 멀티 스래드를 사용한다

스레드풀 : 노드가 특정 동작할떄 스스로 멀티 스레드 사용ex)암호화 입출력 압축
워커스레드 : 노드에서 멀티 스레드를 사용할 수 있게 해준다 

노드 특징
노드는 웹 서버가 내장되어있다 , 개발 언어로 자바스크립트를 사용한다 , 싱글스레드를 사용
CPU연산을 많이 요구하는 작업에는 약하지만 개수는 많지만 작은 데이터를 주고받을떄 유리
JSON과 호환이 잘됨 , 서버 규모가 커졌을 떄 서버 관리가 어렵다 , 스레드가 하나라 그 스레드가
멈추지 않도록 관리해줘야 한다 


노드에서 this
최상위 스코프에 존재하는 this는 module, exports를 가리키지만 함수 안에서의 this는 global객체를 가리킨다

require모듈이나 export모듈은 상단 하단에 위치하지 않아도된다


노드에서 os모듈을 사용하면 운영체제의 정보를 가져올 수 있다.
ex) const os = require('os');  os.type();

__filename : 현재 파일의 이름을 나타낸다
__dirname :현재 폴더의 경로를 나타낸다 
path.extname(string) - 파일의 확장자를 나타낸다 
path.relative(string) - 경로를 두 개 넣으면 첫 번쨰 에서 두 번째 경로로 가는방법을 알려준다 

url모듈은 url에 관한 여러 기능을 제공한다

searchParams : 키와 값을을 모두 가져옴

ex) const {URL} = require('url');
const myURL = new URL('https://github.com/awardfact/makeProgram/tree/master/node?page=3&limit=10&category=nodejs&category=javascript');
console.log('searchParams : ' , myURL.searchParams);
console.log('searchParams.getAll() : ', myURL.searchParams.getAll('category'));
console.log('searchParams.get() :  ' , myURL.searchParams.get('limit'));
console.log('searchParams.has() : ', myURL.searchParams.has('page'));


querystring - WHATWG 방식의 url 대신 기존 노드의 url을 사용할떄 search부분을 사용하기 쉽게 객체로 만드는 모듈

querystring.parse(쿼리) : url의 query부분을 자바스크립트 객채로 분해
querystring.stringify(객체) : 분해된 query객체를 다시 조립한다 

crypto모듈 - 암호화를 도와주는 모듈이다 

해쉬만드는 코드 
ex)const crypto = require('crypto');
console.log('base64 :' , crypto.createHash('sha512').update('password').digest('base64') );
 
createHash(알고리즘) - 해쉬에 사용할 알고리즘을 넣는다
update(문자열) -  변환할 문자열을 넣는다
digest(인코딩) - 인코딩할 알고리즘을 넣는다 base64, hex, latin1이 주로 사용되는데 base가 가장 짧아 많이 이용된다 

현재 주로 비밀번호 알고리즘으로 pbkdf2 , bcrypt, scrypt 사용한다 pbkdf2는 노드에서 지원한다  
사용예시) crypto.pbkdf2('비밀번호' , salt , 10000 , 64, 'sha512' , (err,key) =>{
        console.log('password' ,  key.toString('base64'));
    });

pbkdf2 의 매개변수로 비밀번호, salt, 반복횟수 , 출력 바이트, 해시 알고리즘을 넣는다 

양방향 암호화는 cipher를 이용한다 
사용예시)const algorithm = 'aes-256-cbc';
const key = 'abcdefghijklmnopqrstuvwxyz123456';
const iv = '1234567890123456';
const cipher = crypto.createCipheriv(algorithm,key,iv);
let result = cipher.update('암호화할 문장' , 'utf-8' , 'base64');
result += cipher.final('base64');
console.log('암호화 : ' , result);  
const decipher = crypto.createDecipheriv(algorithm,key,iv);
let result2 = decipher.update(result, 'base64' , 'utf-8');
result2 += decipher.final('utf-8');
console.log('복호화 :' , result2);

util 모듈은 각종 편의 기능들을 모아놓은 모듈이다

노드에서 worker_threads 모듈을 사용하면 멀티 쓰레드를 사용할 수 있다 

child_process모듈을 사용하면 노드에서 다른 프로그램을 실행하거나 명령어를 수행할 수 있다 

fs모듈은 파일 시스템에 접근하는 모듈이다(파일 생성 삭제 읽거나 쓸수 있음)
실무에서 사용할 떄는 fs모듈을 프로미스 형식으로 바꿔주는 방법을 사용한다

동기 메서드들은 이름 뒤에 sync가 붙어있는 경우가 대부분이다

노드는 파일을 읽을 떄 메모리에 파일 크기만큼 공간을 마련해두고 파일 데이터를 메모리에 저장한 뒤
사용자가 조작할 수 있도록 하고 이때 메모리에 저장한 데이터가 버퍼이다.

Buffer.from(문자열)  : 문자열을 버퍼로 바꿀 수 있습니다length속성은 버퍼의 크기를 나타낸다(바이트단위)
Buffer.toString(버퍼) : 버퍼를 다시 문자열로 바꿀 수 있다 
Buffer.concat(배열) : 배열안에 들어있는 버퍼를 하나로 합침ㄹ
Buffer.alloc(바이트) : 빈 버퍼를 생성, 바이트를 인수로 넣으면 해당 크기의 버퍼 생성 

버퍼의 크기가 크면 편리하지만 버퍼에 큰 내용을 쓴 후에 다음 동작을 할 수 있어 문제가 생긴다
그래서 버퍼의 크기를 작게 여러 번 나눠 방식이 생겼는데 이것이 스트림이다
스트림 예시) 
const readStream = fs.createReadStream('./readme3.txt' , {highWaterMark : 16}); 스트림으로 읽기
readStream.on('data' , (chunk)=>{
    data.push(chunk);
    console.log('data : ' , chunk, chunk.length);
});

fs.mkdir 폴더를 만드는 메서드 이미 폴더가 있으면 오류남
fs.readdir(경로, 콜백) : 폴더 안의 내용물을 확인할 수 있다
fs.unlink(경로, 콜백) : 파일을 지울 수 있는 메서드
fs.rmdir(경로, 콜백) : 폴더를 지울 수 있는 메서드 파일이 있으면 에러 
fs.copyFile(복사할파일,, 복사될파일)  :파일을 복사하는 메서드 

스레드풀의 개수를 바꾸는 방법
윈도우 : SET UV_THREADPOOL_SIZE = 1
맥, 리눅스 : UV_THREADPOOL_SIZE=1

events모듈을 사용하면 이벤트를 직접 만들 수 있다 
on(이벤트명 , 콜백) :이벤트 이름과 발생시 콜백 연결한다 addListener과 기능이 같다
emit(이벤트명)  : 이벤트를 호출하는 메서드 
once(이벤트명, 콜백) : 한 번만 실행되는 이벤트 
removeAllListeners(이벤트명) :이벤트에 연결된 모든 이벤트 리스너 제거
removeListener(이벤트명, f리스너) : 이벤트에 연결된 리스너를 하나씩 제거
off(이벤트명, 콜백) : removeListener와 기능 동일 
listenerCOunt(이벤트명)  : 리스너가 몇개 연결되어있는지 확인 

예외처리
멀티스래드에서는 스레드 하나가 멈추면 그 일을 다른 스레드가 대신하는데 노드는 스레드가 하나여서
스렏으가 멈추면 전체가 멈추게 된다 그래서 노드에서는 예외처리가 더욱 중요하다 

예기치 못한 에러는 uncaughtException이벤트로 처리할 수 있지만 해당 이벤트는 최후의 방법이고
이후의 동작을 보증하지 않기 떄문에 로그 기록용으로만 사용하는게 좋다 

자주 발생하는 에러 

node : command not found - 환경변수가 제대로 설정되어있지 않을떄 뜨는 오류
ReferenceError : 모듈 is not defined - 모듈을 require하지 않으면 뜨는 오류
Error : Cannot find module 모듈명 - 모듈을 rquire했지만 설치하지 않은 경우 
Error : Can't set headers after they are sent : 요청에 대한 응답을 보낼 떄 응답을 두번 이상 보낸경우 뜨는 에러
FATAL ERROR : CALL_AND_RETRY_LAST Alloation faild Javascript heap out of memory - 코드를 실행할 떄 메모리가 부족하면 뜨는 오류
UnhandlePromiseRejectionWarning : Unhandled promise rejection - 프로미스 사용 시 catch메서드를 붙이지 않은 경우 생기는 오류 
EADDRINUSE 포트 번호 : 해당 포트 번호에 이미 다른 프로세스가 연결되어있는경우 발생
EACCES 또는 EPERM - 노드가 작업을 수행하는 데 권한이 충분하지 않은 경우 발생
EJSONPARSE - package.json 등의 JSON파일에 문법 오류가 있을 때 발생
ECONNREFUSED - 요청을 보냈으나 연결이 성립되지 않은 경우 발생
ETARGERT - packge.json에 기록한 패키지 버전이 존재하지 않을 떄 발생
ETIMEOUT - 요청을 보냈는데 응답이 일정 시간 내에 오지 않은 경우 발생
ENOENT : no such file or directory - 지정한 폴더나 파일이 존재하지 않는 경우 

aws에서 노드 실행하기

sudo apt-get update 
sudo apt-get install nodejs
sudo apt-get install npm
sudo apt-get install git

이것들 먼저 설치해준다 
 npm start- 서버 실행
$ sudo nohup npm start & - 백그라운드로 서버 실행 

서버 실행을 위한 기본코드 
const http = require('http');
http.createServer((req,res)=>{
    res.writeHead(200, {'Content-type' : 'text/html; charset=utf-8' });
    res.write('<div>hello world</div>');
    res.end('<div>hello Server</div>');
}).listen(8080 , ()=>{
    console.log('8080포트');
});
이 코드를 포트만 바꿔 여러개 넣어서 여러 서버를 동시에 실행할 수도 있다 

rest는 서버 자원을 정의하고 자원에 대한 주소르르 지정하는 방법을 가리킨다 
rest api 메서드
get - 서버 자원을 가져오고자 할때 사용 데이터를 서버로 보낼때는 쿼리스트링을 사용한다
post - 서버에 자원을 새로 등록하고자 할 떄 사용 
put - 서버의 자원을 요청에 들어있는 자원으로 치환할 떄 사용
patch - 서버 자원의 일부만 수정하고자 할떄 사용
delete 서버의 자원을 삭제하고자 할 때 사용 
options - 요청을 하기 전에 통신 옵션을 설명하기 위해 사용 

http 통신을 사용하면 클라이언트가 누구든 상관없이 같은 방식으로 서버와 소통할 수 있다

쿠키를 가져오는거는 
const cookie = req.headers.cookie; 와 같이 가져오고

쿠키를 설정할떄는
res.writeHead(200, {'set-Cookie' : 'mycookie=test'});와 같이 한다 
}

쿠키 설정할떄 옵션은 세미콜론으로 구분하고 다음과 같은 옵션이 있다
쿠키명=쿠키값 
Expires=날짜   - 날짜가 지나면 쿠키가 제거된다 기본값은 클라이언트 종료시
max-age=초 - 날짜대신 해당 초가 지나면 제거된다 expire보다 우선
Domain=도메인명 - 쿠키가 전송될 도메인을 특정할 수 있다 기본값은 현재 도메인
Path=URL - 쿠키가 전송될 URL
Secure : Https인경우에만 쿠키 전송
httpOnly - 자바스크립트에서 쿠키 접근 불가 